// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file DataAir.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}  // namespace
#endif  // _WIN32

#include "DataAir.h"
#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

DataAir::DataAir()
{
    // m_time com.eprosima.idl.parser.typecode.PrimitiveTypeCode@28ac3dc3
    m_time = 0;
    // m_senseTime com.eprosima.idl.parser.typecode.PrimitiveTypeCode@32eebfca
    m_senseTime = 0.0;
    // m_dynamicPress com.eprosima.idl.parser.typecode.PrimitiveTypeCode@4e718207
    m_dynamicPress = 0.0;
    // m_velocity com.eprosima.idl.parser.typecode.PrimitiveTypeCode@1d371b2d
    m_velocity = 0.0;
    // m_baroPress com.eprosima.idl.parser.typecode.PrimitiveTypeCode@543c6f6d
    m_baroPress = 0.0;
    // m_density com.eprosima.idl.parser.typecode.PrimitiveTypeCode@13eb8acf
    m_density = 0.0;
    // m_temp com.eprosima.idl.parser.typecode.PrimitiveTypeCode@51c8530f
    m_temp = 0.0;
    // m_alive com.eprosima.idl.parser.typecode.PrimitiveTypeCode@7403c468
    m_alive = false;

}

DataAir::~DataAir()
{








}

DataAir::DataAir(
        const DataAir& x)
{
    m_time = x.m_time;
    m_senseTime = x.m_senseTime;
    m_dynamicPress = x.m_dynamicPress;
    m_velocity = x.m_velocity;
    m_baroPress = x.m_baroPress;
    m_density = x.m_density;
    m_temp = x.m_temp;
    m_alive = x.m_alive;
}

DataAir::DataAir(
        DataAir&& x)
{
    m_time = x.m_time;
    m_senseTime = x.m_senseTime;
    m_dynamicPress = x.m_dynamicPress;
    m_velocity = x.m_velocity;
    m_baroPress = x.m_baroPress;
    m_density = x.m_density;
    m_temp = x.m_temp;
    m_alive = x.m_alive;
}

DataAir& DataAir::operator =(
        const DataAir& x)
{

    m_time = x.m_time;
    m_senseTime = x.m_senseTime;
    m_dynamicPress = x.m_dynamicPress;
    m_velocity = x.m_velocity;
    m_baroPress = x.m_baroPress;
    m_density = x.m_density;
    m_temp = x.m_temp;
    m_alive = x.m_alive;

    return *this;
}

DataAir& DataAir::operator =(
        DataAir&& x)
{

    m_time = x.m_time;
    m_senseTime = x.m_senseTime;
    m_dynamicPress = x.m_dynamicPress;
    m_velocity = x.m_velocity;
    m_baroPress = x.m_baroPress;
    m_density = x.m_density;
    m_temp = x.m_temp;
    m_alive = x.m_alive;

    return *this;
}

size_t DataAir::getMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t DataAir::getCdrSerializedSize(
        const DataAir& data,
        size_t current_alignment)
{
    (void)data;
    size_t initial_alignment = current_alignment;


    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void DataAir::serialize(
        eprosima::fastcdr::Cdr& scdr) const
{

    scdr << m_time;
    scdr << m_senseTime;
    scdr << m_dynamicPress;
    scdr << m_velocity;
    scdr << m_baroPress;
    scdr << m_density;
    scdr << m_temp;
    scdr << m_alive;

}

void DataAir::deserialize(
        eprosima::fastcdr::Cdr& dcdr)
{

    dcdr >> m_time;
    dcdr >> m_senseTime;
    dcdr >> m_dynamicPress;
    dcdr >> m_velocity;
    dcdr >> m_baroPress;
    dcdr >> m_density;
    dcdr >> m_temp;
    dcdr >> m_alive;
}

/*!
 * @brief This function sets a value in member time
 * @param _time New value for member time
 */
void DataAir::time(
        uint64_t _time)
{
    m_time = _time;
}

/*!
 * @brief This function returns the value of member time
 * @return Value of member time
 */
uint64_t DataAir::time() const
{
    return m_time;
}

/*!
 * @brief This function returns a reference to member time
 * @return Reference to member time
 */
uint64_t& DataAir::time()
{
    return m_time;
}

/*!
 * @brief This function sets a value in member senseTime
 * @param _senseTime New value for member senseTime
 */
void DataAir::senseTime(
        float _senseTime)
{
    m_senseTime = _senseTime;
}

/*!
 * @brief This function returns the value of member senseTime
 * @return Value of member senseTime
 */
float DataAir::senseTime() const
{
    return m_senseTime;
}

/*!
 * @brief This function returns a reference to member senseTime
 * @return Reference to member senseTime
 */
float& DataAir::senseTime()
{
    return m_senseTime;
}

/*!
 * @brief This function sets a value in member dynamicPress
 * @param _dynamicPress New value for member dynamicPress
 */
void DataAir::dynamicPress(
        float _dynamicPress)
{
    m_dynamicPress = _dynamicPress;
}

/*!
 * @brief This function returns the value of member dynamicPress
 * @return Value of member dynamicPress
 */
float DataAir::dynamicPress() const
{
    return m_dynamicPress;
}

/*!
 * @brief This function returns a reference to member dynamicPress
 * @return Reference to member dynamicPress
 */
float& DataAir::dynamicPress()
{
    return m_dynamicPress;
}

/*!
 * @brief This function sets a value in member velocity
 * @param _velocity New value for member velocity
 */
void DataAir::velocity(
        float _velocity)
{
    m_velocity = _velocity;
}

/*!
 * @brief This function returns the value of member velocity
 * @return Value of member velocity
 */
float DataAir::velocity() const
{
    return m_velocity;
}

/*!
 * @brief This function returns a reference to member velocity
 * @return Reference to member velocity
 */
float& DataAir::velocity()
{
    return m_velocity;
}

/*!
 * @brief This function sets a value in member baroPress
 * @param _baroPress New value for member baroPress
 */
void DataAir::baroPress(
        float _baroPress)
{
    m_baroPress = _baroPress;
}

/*!
 * @brief This function returns the value of member baroPress
 * @return Value of member baroPress
 */
float DataAir::baroPress() const
{
    return m_baroPress;
}

/*!
 * @brief This function returns a reference to member baroPress
 * @return Reference to member baroPress
 */
float& DataAir::baroPress()
{
    return m_baroPress;
}

/*!
 * @brief This function sets a value in member density
 * @param _density New value for member density
 */
void DataAir::density(
        float _density)
{
    m_density = _density;
}

/*!
 * @brief This function returns the value of member density
 * @return Value of member density
 */
float DataAir::density() const
{
    return m_density;
}

/*!
 * @brief This function returns a reference to member density
 * @return Reference to member density
 */
float& DataAir::density()
{
    return m_density;
}

/*!
 * @brief This function sets a value in member temp
 * @param _temp New value for member temp
 */
void DataAir::temp(
        float _temp)
{
    m_temp = _temp;
}

/*!
 * @brief This function returns the value of member temp
 * @return Value of member temp
 */
float DataAir::temp() const
{
    return m_temp;
}

/*!
 * @brief This function returns a reference to member temp
 * @return Reference to member temp
 */
float& DataAir::temp()
{
    return m_temp;
}

/*!
 * @brief This function sets a value in member alive
 * @param _alive New value for member alive
 */
void DataAir::alive(
        bool _alive)
{
    m_alive = _alive;
}

/*!
 * @brief This function returns the value of member alive
 * @return Value of member alive
 */
bool DataAir::alive() const
{
    return m_alive;
}

/*!
 * @brief This function returns a reference to member alive
 * @return Reference to member alive
 */
bool& DataAir::alive()
{
    return m_alive;
}


size_t DataAir::getKeyMaxCdrSerializedSize(
        size_t current_alignment)
{
    size_t current_align = current_alignment;











    return current_align;
}

bool DataAir::isKeyDefined()
{
    return false;
}

void DataAir::serializeKey(
        eprosima::fastcdr::Cdr& scdr) const
{
    (void) scdr;
            
}
